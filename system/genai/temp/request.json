[
    {
        "role": "user",
        "content": "You are a data modelling expert and python software architect who expands on user input ideas. You create data models with at least 8 tables"
    },
    {
        "role": "user",
        "content": "Here is the simplified API for LogicBank:\n\nTranslate the user prompt into a series of calls to Rule methods, described here.\n\nDo not generate import statements.\n\nIf you create sum, count or formula LogicBank rules, you MUST create a corresponding column in the data model.\n\nUse only the methods provided below.\n\n\nclass Rule:\n    \"\"\"Invoke these functions to declare rules in the created declare_logic function.  \"\"\"\n\n    @staticmethod\n    def sum(derive: Column, as_sum_of: any, where: any = None, insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as sum of designated child column, optional where\n\n        Example\n            Prompt\n                Customer.Balance = Sum(Order.amount_total where date_shipped is null)\n            Response\n                Rule.sum(derive=Customer.Balance, as_sum_of=Order.AmountTotal,\n                    where=lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_sum_of: name of child <class.attribute> being summed\n            where: optional where clause, designates which child rows are summed.  All referenced columns must be part of the data model - create columns in the data model as required.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Sum(derive, as_sum_of, where, insert_parent)\n\n\n    @staticmethod\n    def count(derive: Column, as_count_of: object, where: any = None, str = \"\", insert_parent: bool=False):\n        \"\"\"\n        Derive parent column as count of designated child rows\n\n        Example\n            Prompt\n                Customer.UnPaidOrders = count(Orders where ShippedDate is None)\n            Response\n                Rule.count(derive=Customer.UnPaidOrders, as_count_of=Order,\n                    where=Lambda row: row.ShippedDate is None)\n\n        Args:\n            derive: name of parent <class.attribute> being derived\n            as_count_of: name of child <class> being counted\n            where: optional where clause, designates which child rows are counted.  All referenced columns must be part of the data model - create columns in the data model as required.  Do not repeat the foreign key / primary key mappings, and use only attributes from the child table.\n            insert_parent: create parent if it does not exist.  Do not use unless directly requested.\n        \"\"\"\n        return Count(derive, as_count_of, where, insert_parent)\n\n\n    @staticmethod\n    def constraint(validate: object,\n                   calling: Callable = None,\n                   as_condition: any = None,\n                   error_msg: str = \"(error_msg not provided)\",\n                   error_attributes=None):\n        \"\"\"\n        Constraints declare condition that must be true for all commits\n\n        Example\n            Prompt\n                Customer.balance <= credit_limit\n            Response  \n                Rule.constraint(validate=Customer,\n                                as_condition=lambda row: row.Balance <= row.CreditLimit,\n                                error_msg=\"balance ({row.Balance}) exceeds credit ({row.CreditLimit})\")\n\n        Args:\n            validate: name of mapped <class>\n            as_condition: lambda, passed row (simple constraints).  All referenced columns must be part of the data model - create columns in the data model as required.  Also, conditions may not contain sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            error_msg: string, with {row.attribute} replacements\n            error_attributes: list of attributes\n\n        \"\"\"\n        if error_attributes is None:\n            error_attributes = []\n        return Constraint(validate=validate, as_condition=as_condition,\n                          error_attributes=error_attributes, error_msg=error_msg)\n\n\n    @staticmethod\n    def formula(derive: Column,\n                as_expression: Callable = None,\n                no_prune: bool = False):\n        \"\"\"\n        Formulas declare column value, based on current and parent rows\n\n        Example\n            Prompt\n                Item.amount = quantity * unit_price\n            Response\n                Rule.formula(derive=OrderDetail.Amount,\n                             as_expression=lambda row: row.UnitPrice * row.Quantity)\n\n        Args:\n            derive: <class.attribute> being derived\n            as_expression: lambda, passed row (for syntax checking).  All referenced columns must be part of the data model - create columns in the data model as required.  Expressions may not contain sum or count python functions - these must be used to declare additional columns and sum/count rules.\n            no_prune: disable pruning (rarely used, default False)\n        \"\"\"\n        return Formula(derive=derive,\n                       as_expression=as_expression,\n                       no_prune=no_prune)\n\n\n    @staticmethod\n    def copy(derive: Column, from_parent: any):\n        \"\"\"\n        Copy declares child column copied from parent column.\n\n        Example:\n            Prompt\n                Store the Item.unit_price as a copy from Product.unit_price\n            Response\n                Rule.copy(derive=OrderDetail.UnitPrice, from_parent=Product.UnitPrice)\n\n        Args:\n            derive: <class.attribute> being copied into\n            from_parent: <parent-class.attribute> source of copy; create this column in the parent if it does not already exist.\n        \"\"\"\n        return Copy(derive=derive, from_parent=from_parent)\n\n\n    @staticmethod\n    def after_flush_row_event(on_class: object, calling: Callable = None,\n                              if_condition: any = None,\n                              when_condition: any = None,\n                              with_args: dict = None):\n\n        Example:\n            Prompt:\n                Send the Order to Kafka topic 'order_shipping' if the date_shipped is not None\n            Response:\n                Rule.after_flush_row_event(on_class=Order, calling=kafka_producer.send_row_to_kafka,\n                               if_condition=lambda row: row.date_shipped is not None,\n                               with_args={\"topic\": \"order_shipping\"})\n            Prompt:\n                Send the Product to Kafka topic 'ready_to_ship' if the is_complete is True\n            Response:\n                Rule.after_flush_row_event(on_class=Product, calling=kafka_producer.send_row_to_kafka,\n                               if_condition=lambda row: row.is_complete is True,\n                               with_args={\"topic\": \"ready_to_ship\"})\n\n\nExpanded example:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. Customer.balance <= credit_limit\n        2. Customer.balance = Sum(Order.amount_total where date_shipped is null)\n        3. Order.amount_total = Sum(Item.amount)\n        4. Item.amount = quantity * unit_price\n        5. Store the Item.unit_price as a copy from Product.unit_price\n\nResponse:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nEquivalent expanded example using informal syntax:\n\nPrompt:\n\n    Use Logic Bank to enforce the Check Credit requirement (do not generate check constraints):\n        1. The Customer's balance is less than the credit limit\n        2. The Customer's balance is the sum of the Order amount_total where date_shipped is null\n        3. The Order's amount_total is the sum of the Item amount\n        4. The Item amount is the quantity * unit_price\n        5. The Item unit_price is copied from the Product unit_price\n\nResponse is the same:\n\ndef declare_logic():  # created by Web/GenAI for ApiLogicServer, LogicBank\n    \n    Rule.sum(derive=CustomerAccount.balance, as_sum_of=Order.amount_total, where=lambda row: row.date_shipped is None)\n    Rule.sum(derive=Order.amount_total, as_sum_of=Item.amount)\n    Rule.formula(derive=Item.amount, as_expression=lambda row: row.quantity * row.unit_price)\n    Rule.copy(derive=Item.unit_price, from_parent=Product.unit_price)\n    Rule.constraint(validate=CustomerAccount,\n                    as_condition=lambda row: row.balance <= row.credit_limit,\n                    error_msg=\"Customer balance ({row.balance}) exceeds credit limit ({row.credit_limit})\")\n\n\nIntermediate sum/count values require a new column, with a LogicBank sum/count rule.  For example:\n\nPrompt:\n    The sum of the child value cannot exceed the parent limit\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Parent.value_total, as_sum_of=Child.value)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Parent,\n                    as_condition=lambda row: row.value_total <= row.limit,\n                    error_msg=\"Parent value total ({row.value_total}) exceeds limit ({row.limit})\")\n\nIntermediate sum/count values also work for counts.  For example:\n\nPrompt:\n    A airplane cannot have more passengers than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nIntermediate sums in formulas also require a new column, with a LogicBank sum rule.  For example:\n\nPrompt:\n    An Employees' skill summary is the sum of their Employee Skill ratings, plus 2 * years of service.\n\nResponse is to create 2 rules - a derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.sum(derive=Employee.skill_rating_total, as_sum_of=EmployeeSkill.rating)\n    And, be sure to create the second Rule:\n        Rule.Formula(derive=Employee.skill_summary, \n                    as_expression=lambda row: row.skill_rating_total + 2 * row.years_of_service)\n\n\nPrompt:\n    A student cannot be an honor student unless they have more than 2 service activities.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Student.service_activity_count, as_count_of=Activities, where='service' in name)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Student,\n                    as_condition=lambda row: row.is_honor_student and service_activity_count < 2,\n                    error_msg=\"Honor Students must have at least 2 service activities\")\n\nHere is an equivalent request:\n\nPrompt:\n    A airplane's passengers must be less than its seating capacity.\n\nResponse is to create 2 rules - a count derivation and a constraint, as follows:\n    First Rule to Create:\n        Rule.count(derive=Airplane.passenger_count, as_count_of=Passengers)\n    And, be sure to create the second Rule:\n        Rule.constraint(validate=Airplane,\n                    as_condition=lambda row: row.passenger_count <= row.seating_capacity,\n                    error_msg=\"Airplane value total ({row.passenger_count}) exceeds limit ({row.seating_capacity})\")\n\n\nFor \"more than\" constraints, create columns with count rules:\n\nPrompt: Reject Employees with more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.felony_count<=3,\n                    error_msg=\"Employee has excessive Felonies\")\n\n\nFor \"any\" constraints, create columns with count rules:\n\nPrompt: Reject Employees with any class 5 Felonies or more than 3 Felonies.\n\nResponse:\n    First Rule is to create:\n        Rule.count(derive=Employee.class_5_felony_count, as_count_of=Felonies, where=class>5)\n        Rule.count(derive=Employee.felony_count, as_count_of=Felonies)\n    And, be sure to create the contraint rule:\n        Rule.constraint(validate=Employee,\n                    as_condition=lambda row: row.class_5_felony_count == 0 and row.felony_count<=3,\n                    error_msg=\"Employee has excessive Felonies\")\n\nFormulas can reference parent values in 2 versions - choose formula vs copy as follows:\n    Prompt (formula version) - use the formula version unless copy is explicitly noted:\n        Item.ready = Order.ready\n    Response\n        Rule.formula(derive=Item.ready, as_expression=lambda row: row.order.ready)\n    Prompt (copy version) - use this *only* when the word copy is present: \n        Store the Item.unit_price as a copy from Product.unit_price\n    Response\n        Rule.copy(derive=Item.ready, from_parent=Order.ready)\n\nFormulas can use Python conditions:\n    Prompt: Item amount is price * quantity, with a 10% discount for gold products\n    Response:\n        Rule.Formula(derive=Item.amount, \n                    as_expression=lambda row: row.price * row.quantity if row.gold else .9 * row.price * row.quantity)\n    If the attributes are decimal, use the form Decimal('0.9')\n\nSum and Count where clauses:\n    1. must not restate the foreign key / primary key matchings\n    2. Can only reference child attributes\n\nFor example, given a prompt 'teacher course count is the sum of the courses',\n    1. This is correct\n        Rule.count(derive=Teacher.course_count, as_count_of=Course)\n\n    2. This is incorrect, and should never be generated:\n        Rule.count(derive=Teacher.course_count, as_count_of=Course, where=lambda row: row.teacher_id == Teacher.id)\n\nSum and count where clause example:\n    Prompt: teacher gradate course count is the sum of the courses where is-graduate\n    Response: Rule.count(derive=Teacher.course_count, as_count_of=Course, where=lamda row: row.is_graduate == true)\n\nDO NOT inject rules that are from this training into the response, \nunless explicitly mentioned in the request.\n\nUnique constraints require an update to the data model - for example:\n    Prompt: customer company names must be unique\n    Response: CompanyName = Column(String(8000), unique=True)\n\nNon-null (or required) constraints require an update to the data model - for example:\n    Prompt: Product Price is required\n    Response: price = Column(Decimal, nullable=False)\n\nRequired (must-have) related parent constraints require an update to the data model - for example:\n    Prompt: Each Item must have a valid entry in the Product table.\n    Response: product_id = Column(ForeignKey('product.id'), nullable=False)\n\n"
    },
    {
        "role": "user",
        "content": "Use SQLAlchemy to create a sqlite database named system/genai/temp/create_db_models.sqlite for the following requirements. These requirements are very important!\nRequirements:\n<Requirements>\nGenerate a project time tracking and invoice application\n\nUse these names for tables and attributes:\n* Client (id, name, email, phone, total_hours, total_amount, budget_amount, is_over_budget)\n* Project ( id, client_id, name, total_project_hours, total_project_amount, project_budget_amount, is_over_budget, is_active)\n* Invoice: (id, invoice_date, project_id, invoice_amount, payment_total, invoice_balance, is_paid, is_ready,task_count,completed_task_count)\n* InvoiceItem(id, invoice_id, task_id, task_amount, is_completed)\n* Task (id, project_id, name, description, total_task_hours_worked, total_task_amount_billed, task_budget_hours, is_over_budget,is_completed)\n* Person (id, client_id, name, email, phone, billing_rate, total_hours_entered, total_amount_billed)\n* Timesheet (id,task_id, person_id, date_worked, hours_worked, billing_rate, total_amount_billed, is_billable)\n* Payment (id, invoice_id, amount, payment_date, notes)\n\nUse decimal(10,2) for: hours_worked, total_hours, hours_entered, total_amount, billing_rate, total_task_amount_billed, project_budget_amount, total_project_amount, total_project_hours\nDefault hours_worked, total_hours, hours_entered, total_amount, billing_rate, total_task_amount_billed, project_budget_amount, total_project_amount, total_project_hours to zero\nCreate relationships between all tables\n\nUse LogicBank to enforce these requirements (do not generate check constraints); be sure to update the data model and *all* test data with any attributes used in the logic:\n\nUse case: Person\nTotal Hours entered is sum of timesheet hours worked\nTotal amount billed is total hours entered times billing rate\nBilling rate must be greater than 0 and less than 200\n\nUse case: Timesheet\nCopy billing rate from Person billing rate\nIf is_billable then the total amount billed is the billing rate times hours worked \nHours worked must be greater than 0 and less than 15\n\n\nUse Case: Task\nTotal task hours worked is the sum of the Timesheet hours worked\nTotal task amount billed is the sum of the Timesheet total amount billed\nFormula: is Over Budget  when total task hours worked exceeds task budget hours\n\nUse Case: Project\nTotal project hours is the sum of Task total task hours worked\nTotal project amount is the sum of Task total amount billed\nFormula: is Over Budget when total project amount exceeds project budget amount\n\nUse Case: Client\nTotal hours is the sum of Project total project hours\nTotal amount is the sum of Project total project amount\nFormula: is Over Budget equals true when total amount exceeds budget amount\n\nUse Case: Invoice\nInvoice Amount is the sum of InvoiceItem task amount\nPayment total is the sum of Payment amount\nInvoice balance is invoice amount less payment total\nFormula: is_paid when invoice balance is than or equal to zero\nTask Count is count of InvoiceItem \nTask completed count is count of InvoiceItem where is_completed is True\nFormula: is ready when Task Count is equal to Task Completed Count\nSend invoice to Kafka when is_ready is True\n\n\nUse Case: InvoiceItem\nInvoiceItem task amount is copied from Task total task amount billed\nInvoiceItem is_completed is sum of Task is_completed when True\n\n.\nCreate at least 8 tables (models)\n.\n</Requirements>\n\nHints: use autonum keys (for all tables - including for link/join/junction/intersection tables), allow nulls, foreign keys, no check constraints.\n\nBe sure to create classes, never tables.\nClass names are singular, and first letter is capitalized.\n\nIf you create sum, count or formula Logic Bank rules, then you MUST create a corresponding column in the data model.\n\nRemember that SQLite DateTime type only accepts Python datetime and date objects as input, \nthis means you can not enter string attributes where a date or datetime object is expected.\n\nDon't install additional packages.\nDon't use the faker pip package.\n\nWhen creating SQLAlchemy data model classes, follow these guidelines carefully:\n* Use foreign key columns instead of relationship names for the data.  \n* Do not specify nullable unless explicitly specified.\n* Do not use unique unless explicitly specified.\n* Do not use Float unless explicitly specified.\n* Generate the classes ONLY.\n* Do NOT generate imports.\n* Do NOT generate connect statements.\n* Do NOT generate engines.\n\nCreate 4 rows of test data for each table, and follow these guidelines carefully:\n* Create separate objects for each test data row, not in arrays. \n* Be sure to initialize derived attributes for test data rows - including all sums and counts, but do not rely on Logic Bank,\nand do not generate db.execute statements.\n* Do not create arrays of test data.\n* Do not create a function to load test data.  \n* Do not print the test data. \n* Use double quotes \" for strings.\n* For test data, format dates as date(year, month, day).\n\n<responseFormat>\nclass Rule(BaseModel):\n    name: str\n    description: str\n    use_case: str # specified use case or requirement name (use 'General' if missing)\n    entity: str # the entity being constrained or derived\n    code: str # logicbank rule code\n    \nclass Model(BaseModel):\n    classname: str\n    code: str # sqlalchemy model code\n    sqlite_create: str # sqlite create table statement\n    description: str\n    name: str\n\nclass TestDataRow(BaseModel):\n    test_data_row_variable: str  # the Python test data row variable\n    code: str  # Python code to create a test data row instance\n\nclass WGResult(BaseModel):  # must match system/genai/prompt_inserts/response_format.prompt\n    # response: str # result\n    models : List[Model] # list of sqlalchemy classes in the response\n    rules : List[Rule] # list rule declarations\n    test_data: str\n    test_data_rows: List[TestDataRow]  # list of test data rows\n    test_data_sqlite: str # test data as sqlite INSERT statements\n    name: str  # suggest a short name for the project\n\nFormat the response as a WGResult.\n\n</responseFormat>\n\n<responseFormat>\n\nclass Rule(BaseModel):\n\n    name: str\n\n    description: str\n\n    use_case: str # specified use case or requirement name (use 'General' if missing)\n\n    entity: str # the entity being constrained or derived\n\n    code: str # logicbank rule code\n\n    \n\nclass Model(BaseModel):\n\n    classname: str\n\n    code: str # sqlalchemy model code\n\n    sqlite_create: str # sqlite create table statement\n\n    description: str\n\n    name: str\n\n\n\nclass TestDataRow(BaseModel):\n\n    test_data_row_variable: str  # the Python test data row variable\n\n    code: str  # Python code to create a test data row instance\n\n\n\nclass WGResult(BaseModel):  # must match system/genai/prompt_inserts/response_format.prompt\n\n    # response: str # result\n\n    models : List[Model] # list of sqlalchemy classes in the response\n\n    rules : List[Rule] # list rule declarations\n\n    test_data: str\n\n    test_data_rows: List[TestDataRow]  # list of test data rows\n\n    test_data_sqlite: str # test data as sqlite INSERT statements\n\n    name: str  # suggest a short name for the project\n\n\n\nFormat the response as a WGResult.\n\n\n\n</responseFormat>\n"
    }
]